# -*- coding: utf-8 -*-
"""Intro to Numpy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JqfoM65KVeq1chIWC_57AzMc5fTnRtwf

# NumPy (Numerical Python)

Numpy is the core library for scientific computing in Python. It provides a high-performance multidimensional array object, and tools for working with these arrays.


*   An open source extension module for Python.
*   provides fast precompiled functions for mathematical and numerical routines.
*   Focuses on huge matrices and arrays.
*   Supplies a large library of high-level mathematical functions to operate on these matrices and arrays.

**Advantages of using Numpy**

*   Array Oriented Computing.
*   Efficiently implemented multi-dimensional arrays.
*   Designed for scientific computation

# **numpy Arrays**
"""

import numpy as np

#1D Array

a=np.array([1,2,3])
print(a)

a=np.array([(1,2,3),(4,5,6)])
print(a)

"""# NumPy Array v/s List

Reasons to choose numpy array v/s Python lists:


1.   Less Memory Consumption
2.   Fast
2.   Convinient
"""

#Size Comparison between numpy array and list
import numpy as np
from sys import getsizeof as size

lst = [1,2,3]
size_of_elements = len(lst) * size(0)
size_of_list_object = size(lst)   
total_list_size = size_of_list_object + size_of_elements
print("Size without the size of the elements: ", size_of_list_object)
print("Size of all the elements: ", size_of_elements)
print("Total size of list, including elements: ", total_list_size)

print()

arr=np.array([1,2,3])
size_of_elements = arr.itemsize * arr.size
size_of_array_object = size(arr) - size_of_elements
total_list_size = size(arr)
print("Size without the size of the elements : ", size_of_array_object)
print("Size of all the elements: ", size_of_elements)
print("Total size of list, including elements: ", total_list_size)

"""**Aggregate Functions : max/min/sum**"""

a= np.array([54,76,45,76,45,76,23,43,687,54,-23])
print(a.min())
print(a.max())
print(a.sum())

"""# Creating numpy Arrays

**arange**

arange([start,] stop[, step], [, dtype=None])

arange returns evenly spaced values within a given interval. The values are generated within the half-open interval '[start, stop)' If the function is used with integers, it is nearly equivalent to the Python built-in function range, but arange returns an ndarray rather than a list iterator as range does. If the 'start' parameter is not given, it will be set to 0. The end of the interval is determined by the parameter 'stop'. Usually, the interval will not include this value, except in some cases where 'step' is not an integer and floating point round-off affects the length of output ndarray. The spacing between two adjacent values of the output array is set with the optional parameter 'step'. The default value for 'step' is 1.
"""

import numpy as np

a = np.arange(1, 10)
print(a)

#x = range(1, 10)
#print(x)    # x is an iterator
#print(list(x))

# further arange examples:
x = np.arange(10.4)
print(x)

x = np.arange(0.5, 10.4, 0.8)
print(x)

x = np.arange(0.5, 10.4, 0.8, int)
print(x)

"""## **linspace**

linspace(start, stop, num=50, endpoint=True, retstep=False)

linspace returns an ndarray, consisting of 'num' equally spaced samples in the closed interval [start, stop] or the half-open interval [start, stop). If a closed or a half-open interval will be returned, depends on whether 'endpoint' is True or False. The parameter 'start' defines the start value of the sequence which will be created. 'stop' will the end value of the sequence, unless 'endpoint' is set to False. In the latter case, the resulting sequence will consist of all but the last of 'num + 1' evenly spaced samples. This means that 'stop' is excluded.
"""

import numpy as np

# 50 values between 1 and 10:
print(np.linspace(1, 10))

# 7 values between 1 and 10:
print(np.linspace(1, 10, 7))

# excluding the endpoint:
print(np.linspace(1, 10, 7, endpoint=False))

"""**Zero Dimensional Array**

It's possible to create multidimensional arrays in numpy. Scalars are zero dimensional in numpy
"""

import numpy as np
x = np.array(99)
print("x: ", x)
print("The type of x: ", type(x))
print("The dimension of x:", np.ndim(x))

"""**One Dimensional Array**

Numpy arrays are containers of items of the same type, e.g. only integers. The homogenous type of the array can be determined with the attribute "dtype"
"""

F = np.array([1, 1, 2, 3, 5, 8, 13, 21])
V = np.array([3.4, 6.9, 99.8, 12.8])

print("F: ", F)
print("V: ", V)

print("Type of F: ", F.dtype)
print("Type of V: ", V.dtype)

print("Dimension of F: ", np.ndim(F))
print("Dimension of V: ", np.ndim(V))

"""**M Dimensional Array**"""

B = np.array([ [[111, 112], [121, 122]],
               [[211, 212], [221, 222]],
               [[311, 312], [321, 322]] ])
print("Elements of B : ", B)
print("Dimension of B : ", B.ndim)

"""**shape**

"shape" returns the shape of an array. The shape is a tuple of integers. These numbers denote the lengths of the corresponding array dimension.
"""

x = np.array([ [67, 63, 87],
               [77, 69, 59],
               [85, 87, 99],
               [79, 72, 71],
               [63, 89, 93],
               [68, 92, 78]])
print(np.shape(x))


#"shape" can also be used to change the shape of an array.

x.shape = (3, 6)
print(x)

x.shape = (2, 9)
print(x)

"""**reshape**

Reshape changes the number of rows and columns in an array which gives a new view to an object.
"""

x = np.array([ [67, 63, 87],
               [77, 69, 59],
               [85, 87, 99],
               [79, 72, 71],
               [63, 89, 93],
               [68, 92, 78]])
print(np.shape(x))

y=x.reshape(2,9)
print(y)

"""**arrays of ones and zeroes**

There are two ways of initializing Arrays with Zeros or Ones.
"""

F = np.ones((3,4),dtype=int)
print(F)

Z = np.zeros((2,4))
print(Z)

"""**Identity Array (NXN Matrix)**

identity(n, dtype=None)

The output of identity is an 'n' x 'n' array with its main diagonal set to one, and all other elements are 0.
"""

np.identity(4, dtype=int)

"""**Data Type Objects, dtype**

dtype allows to create "Structured Arrays", - also known as "Record Arrays". The structured arrays provides the ability to have different data types per column.
"""

dt = np.dtype([('country', 'S20'), ('density', 'i4'), ('area', 'i4'), ('population', 'i4')])

population_table = np.array([
    ('Netherlands', 393, 41526, 16928800),
    ('Belgium', 337, 30510, 11007020),
    ('United Kingdom', 256, 243610, 62262000),
    ('Germany', 233, 357021, 81799600),
    ('Liechtenstein', 205, 160, 32842),
    ('Italy', 192, 301230, 59715625),
    ('Switzerland', 177, 41290, 7301994),
    ('Luxembourg', 173, 2586, 512000),
    ('France', 111, 547030, 63601002),
    ('Austria', 97, 83858, 8169929),
    ('Greece', 81, 131940, 11606813),
    ('Ireland', 65, 70280, 4581269),
    ('Sweden', 20, 449964, 9515744),
    ('Finland', 16, 338424, 5410233),
    ('Norway', 13, 385252, 5033675)],
    dtype=dt)

print(population_table)

print("Countries : ", population_table['country'])

"""**Input and Output of Structured Arrays**"""

np.savetxt("population_table.csv",
           population_table,
           fmt="%s;%d;%d;%d",           
           delimiter=";")

dt = np.dtype([('country', np.unicode, 20), ('density', 'i4'), ('area', 'i4'), ('population', 'i4')])
x = np.genfromtxt("population_table.csv",
               dtype=dt,
               delimiter=";")
print(x)

"""**Exercise**

Define a structured array with two columns. The first column contains the product ID, which can be defined as an int32. The second column shall contain the price for the product. How can you print out the column with the product IDs, the first row and the price for the third article of this structured array?
"""

mytype = [('productID', np.int32), ('price', np.float64)]
stock = np.array([(34765, 603.76), 
                  (45765, 439.93),
                  (99661, 344.19),
                  (12129, 129.39)], dtype=mytype)

print(stock[2]["price"])

"""# **Numerical Operations on numpy arrays**"""

#Using Scalars

a= np.array([1,2,3])

print(a*5)
print(a-5)
print(a*a)


#Arithmetic Operations with Two arrays

A = np.array([ [11, 12, 13], [21, 22, 23], [31, 32, 33] ])
B = np.ones((3,3))

print("Adding to arrays: ")
print(A + B)
print("Multiplying two arrays: ")
print(A * (B + 1))
print("Matrix Multiplication:")
print(np.dot(A,B))

"""**Logical Operations**"""

a = np.array([ [True, True], [False, False]])
b = np.array([ [True, False], [True, False]])
print(np.logical_or(a, b))
print(np.logical_and(a, b))
print(np.array_equal(a,b))

"""**Distance Matrix**

In mathematics, computer science and especially graph theory, a distance matrix is a matrix or a two-dimensional array, which contains the distances between the elements of a set, pairwise taken.
"""

cities = ["Barcelona", "Berlin", "Brussels", "Bucharest",
          "Budapest", "Copenhagen", "Dublin", "Hamburg", "Istanbul",
          "Kiev", "London", "Madrid", "Milan", "Moscow", "Munich",
          "Paris", "Prague", "Rome", "Saint Petersburg", 
          "Stockholm", "Vienna", "Warsaw"]
dist2barcelona = [0,  1498, 1063, 1968, 
                  1498, 1758, 1469, 1472, 2230, 
                  2391, 1138, 505, 725, 3007, 1055, 
                  833, 1354, 857, 2813, 
                  2277, 1347, 1862]
dists =  np.array(dist2barcelona[:12])
print(dists)
print(np.abs(dists - dists[:, np.newaxis]))

"""# Concatenating, Flattening and Adding Dimensions

**flatten**

flatten is a ndarry method with an optional keyword parameter "order". order can have the values "C", "F" and "A". The default of order is "C". "C" means to flatten C style in row-major ordering, i.e. the rightmost index "changes the fastest" or in other words: In row-major order, the row index varies the slowest, and the column index the quickest, so that a[0,1] follows [0,0]. 
"F" stands for Fortran column-major ordering. "A" means preserve the the C/Fortran ordering.
"""

A = np.array([[[ 0,  1],
               [ 2,  3],
               [ 4,  5],
               [ 6,  7]],
              [[ 8,  9],
               [10, 11],
               [12, 13],
               [14, 15]],
              [[16, 17],
               [18, 19],
               [20, 21],
               [22, 23]]])
Flattened_X = A.flatten()
print(Flattened_X)
print(A.flatten(order="C"))
print(A.flatten(order="F"))
print(A.flatten(order="A"))